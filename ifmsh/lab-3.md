---
layout: default_no_header
title: Лабораторная работа 3
---

> — Я вчера у вас бракованные шарики купил...  
> — Что, сдуваются или лопаются?  
> — Нет, просто не радуют они меня...

## Теория

Всем известна игра в жанре [Match-3]({{site.baseurl}}/ifmsh/lab-3-game). Такой тип игр подразумевает объединение на поле шариков в комбинации из 3 или больше,
после чего они лопаются добавляя очки в копилку. А если повезет, то исчезнувшие шарики повлекут за собой комбинацию исчезновений
других шариков. Обычно в таких играх также сверху добавляются новые шарики, забивая пустоты.

В данной задаче добавление новых шариков не будет, а сами шарики будут заменены на числа.

<img class="img-small" src="{{site.baseurl}}/resources/ifmsh/lab-3/07_demotivator.png">

### Команды

Для создания алгоритма требуется использовать следующие **фиксированные** конструкции:

- `get(<x>, <y>)` - получение значения с поля по указанным координатам
- `create(<name>[, <size>][, <structure>|<type>])` - создать переменную или переменную со структурой (`array`, `list`, `stack`, `queue`, 
`dict`, `matrix`), размер можно задать в произвольном формате
- `stop(<results>)` - завершает программу

> `<` и `>` не относятся к программе, они показывают, что данная часть кода заменяется каким либо именем или структурой.
> `[...]` означает необязательную структуру.

Получения данных и переменных производится в произвольном формате (в каком захотите). Циклы и тому подобные конструкции 
использовать либо из языков программирования, либо расписать свой формат (желательно использовать латиницу, можно расписать
в БНФ). Если используете какую-то функцию, то распишите как она работает (в формате программы).

Клетки с шариками имеют обозначения от 1 до 5, пустая - ноль.

#### Пример алгоритма

Данный алгоритм лопает комбинацию внизу поля и возвращает количество лопнутых элементов (тут всегда 1, потому что 
иначе и не может быть)

```
create(popped);
popped = 0;
if (field(0, 0) == field(1, 0) == field(2, 0)) {
    pop(0, 0);
    popped = popped + 1;
}
stop(popped);
```

Если хотите чтобы ваш алгоритм был читаем: используйте отступы и разделители команд (например, точки с запятой) 

## Задача

Дано прямоугольное поле, размеры поля сохранены в константах `size_x` и `size_y`. Ось абсцисс идет **слева направо**. Ось 
ординат **снизу вверх**. Задачи решаются только последовательно. Если предыдущая задача не была решена хотя бы на половину,
то остальное решение не засчитывается.

**+1 балл**  
Ваша задача проверить, можно ли сдвинуть шарик по указанным координате и направлению (для получения комбинации). Не забывайте
учитывать границы поля.

<img class="img-small" src="{{site.baseurl}}/resources/ifmsh/lab-3/00_zero_field.png">

> **После выполнения будет доступна команда:** `move(<x>, <y>, <dir>)` - сдвинуть шарик на поле (если это возможно), указав 
> направление (`up`, `down`, `left`, `right`), используется не только для создания групп шариков, но и для смещения после 
> изменения поля (учет физики падения)

**+1 балл**  
Требуется сделать проверку на то, можно ли лопнуть шарик, а если можно, то лопнуть все шарики в комбинации.

> **После выполнения будет доступна команда:** `pop(<x>, <y>)` - лопнуть шарик на поле (если это возможно), 
> если лопнуть один шарик, то группа шариков лопнется вместе с ним

**+0.5 балла**  
На поле **забыли** лопнуться несколько комбинаций, лопните их всех. Падение шариков не учитывать. 
Передвигать шарики не нужно. Лопнуть нужно только один шарик, остальные лопнутся сами (так как это было сделано в 
прошлой задаче). 

<img class="img-small" src="{{site.baseurl}}/resources/ifmsh/lab-3/01_first_field.png">
<img class="img-small" src="{{site.baseurl}}/resources/ifmsh/lab-3/02_first_field_sol.png">

**+1.25 балла**  
Найти максимальную комбинацию из шариков, которую можно составить передвинув один шарик. Укажите координату и 
направление сдвига в ответе, а также результат в очках (количество убранных шариков).

<img class="img-small" src="{{site.baseurl}}/resources/ifmsh/lab-3/03_second_field.png">
<img class="img-small" src="{{site.baseurl}}/resources/ifmsh/lab-3/04_second_field_sol.png">

> Ответ в примере: (2, 4, "up"), 5 очков

**+1.25 балла**  
Теперь добавим физику. Найдите максимальную комбинацию из лопающихся комбинаций, которые возникают после лопанья первой 
комбинации. Укажите координату и направление сдвига в ответе, а также результат в очках (количество убранных шариков).
Новые комбинации лопаться автоматически не будут.

<img src="{{site.baseurl}}/resources/ifmsh/lab-3/05_hard.png">

> Ответ в примере: (1, 0, "up"), 13 очков

<img src="{{site.baseurl}}/resources/ifmsh/lab-3/06_hard_2.png">

> Ответ в примере: (3, 1, "down"), 19 очков

Комбинации смещений и координат могут быть разными (так как можно сдвинуть не саму клетку, а её соседа и получить тот 
же результат).

### Редактор

Для большего удобства можно пользоваться редактором (в отчет можно сохранить скриншот, но не желательно).

<div class="code"><textarea class="code-editor">create(popped, array[1]);
popped[0] = 0;
if (field(0, 0) == field(1, 0) == field(2, 0)) {
    pop(0, 0);
    popped = popped[0] + 1;
}
stop("result", popped);</textarea></div>

### Что происходит в задачах?

Вашей задачей является симуляция игры, а точнее одного хода. Вы должны максимизировать прирост очков именно за этот ход, не
рассматривая дальнейшей выгоды.
