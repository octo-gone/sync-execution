---
layout: docs
title: Соединение узлов и работа программы
---
## Создание программы

Главным в программировании является не только правильный алгоритм, но и правильная реализация его на языке.
Особенно правильно если будут использоваться все возможности языка для упрощения программирования. Частым 
примером такого является использование уже встроенных функций или конструкций, а не создание своего велосипеда 
с быстрой сортировкой и сложением матриц.

Конечно, реализация программы также ложится на понимание устройства языка, потому следующая информация поможет как
в понимании работы программы, так и в понимании работы языка.

### Коннекторы и возможные подключения <a id="connectors"></a>

Коннектор - представляет собой вход или выход информации и сигнала из узла. 

Узлы всегда имеют одиночный коннектор на **выходе**, это показывает то, что выход не может отдавать 
множество информации (за редким исключением), так как передача
данных чаще всего это упорядоченная, порционная отдача.

Узлы позволяют получать множественные данные на **входе**, но и в этом есть ограничение, так как узел не сохраняет 
последовательность в которой было отданы данные, а последовательность подключения также не влияет на это (только если косвенно).

<img src="{{site.baseurl}}/resources/docs/program-construction/01_connectors.png"/>

### Порядок запуска узлов <a id="running"></a>

В самом начале обработчик ищет начальный узел - стартовый (Run), который сразу после создания имеет активное состояние 
и пытается активировать следующий узел. 

Активация узла происходит в зависимости от функционала узла, однако большая часть из узлов отрабатывается сразу при 
подаче информации на все порты и получения сигнала хотя бы на один порт. А после завершения выполнения узла, сигнал будет отправлен
на все последующие узлы (по одному порту или по всем). Например узел Run активирован в самом начале, а узел Const без входа
будет всегда деактивирован, однако обрабатываться он все же будет.

При активации узла может происходить несколько действий:

1. Узел проигнорирует входной сигнал
2. Узел обработает сигнал и изменит данные внутри себя (состояние)
3. Узел обработает сигнал и выполнится

Игнорирование входного сигнала обычное дело, так как не всегда требуется активировать узел с указанного входа. 
А обработка сигнала, но не выполнение, позволяет подготавливать данные к последующему запуску,
например, цикл запустится только если подать сигнал на запуск, в остальных случаях все входные сигналы, он будет
обрабатывать и сохранять значения с них, например, в границы цикла. 

### Обратный запрос <a id="callback"></a>

Обратный запрос - получение данных с предыдущих узлов, даже без учета того обрабатывались они с активным сигналом или нет.
Это позволяет не держать активными узлы, если они не смогли отдать данные. Также такая механика обусловлена работой обработчика.
Данные передаются не через соединения и не через активные сигналы, они запрашиваются узлов из предыдущих узлов.

Рассмотрим работу следующей программы. Видно, один из узлов Const был активирован через узел Run, но как известно, пока
узел Add не получит сигнал или данные со всех входных узлов он не сможет обработаться. Потому возникает противоречие, так как
узел Const (без входа) не может быть активирован, следовательно, и обработан, но программа будет работать правильно, так как он 
всегда имеет в себе какое-то значение и узел Add с легкостью получит его. 

<img src="{{site.baseurl}}/resources/docs/program-construction/02_callback.png"/>

> Однако узел Add не будет активирован прежде чем его запустит Const (со входом), так как второй Const не может активировать его.

[index]: {{site.baseurl}}/index
[tutorials]: {{site.baseurl}}/tutorials#content
[docs]: {{site.baseurl}}/docs#content
[drawio]: https://app.diagrams.net/?splash=0&libs=0&clibs=Uhttps://raw.githubusercontent.com/octo-gone/sync-execution/master/resources/base.drawio;Uhttps://raw.githubusercontent.com/octo-gone/sync-execution/master/resources/structure.drawio
[replit]: https://repl.it/github/octo-gone/sync-execution