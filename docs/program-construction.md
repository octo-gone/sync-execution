---
layout: default_no_header
return_page: /docs
return_title: К документации
title: Соединение узлов и работа программы
---
## Создание программы

Главным в программировании является не только правильный алгоритм, но и правильная реализация его на языке.
Особенно если будут использоваться все возможности языка для упрощения программирования. Частым 
примером такого является использование уже встроенных функций или конструкций, а не создание своего велосипеда 
с быстрой сортировкой и сложением матриц.

Конечно, реализация также ложится на понимание устройства языка, следующая информация в этом поможет.

### Коннекторы и возможные подключения <a id="connectors"></a>

**Коннектор** представляет собой вход или выход информации и сигнала из узла. 

Узлы всегда имеют одиночный коннектор на **выходе**; это показывает то, что выход не может отдавать 
множество информации (за редким исключением), так как чаще всего передача
данных это упорядоченная, порционная отдача.

К одиночному **входному коннектору** Узла, может быть подключен только один Узел, однако узлы все же позволяют 
получать множественные данные на **входе**, но и в этом есть ограничение, так как узел не сохраняет 
последовательность в которой были переданы данные, последовательность подключения также не влияет на это (если только косвенно).

<img src="{{site.baseurl}}/resources/docs/program-construction/01_connectors.png"/>

### Порядок запуска узлов <a id="running"></a>

В самом начале обработчик ищет начальный узел - стартовый (Run), который сразу после создания имеет активное состояние 
и пытается активировать следующий. 

Активация узла происходит в зависимости от его функционала, однако большая часть из узлов отрабатывается сразу при 
подаче информации на все порты и получении сигнала хотя бы на один порт. А после завершения выполнения узла сигнал будет отправлен
на все последующие узлы (по одному порту или по всем). Например, Run активирован в самом начале, а Const (без входа)
будет всегда деактивирован, однако обрабатываться он все же будет.

При активации узла может происходить несколько действий:

1. Узел проигнорирует входной сигнал
2. Узел обработает сигнал и изменит данные внутри себя (состояние)
3. Узел обработает сигнал и выполнится

Игнорирование входного сигнала обычное дело - так как не всегда требуется активировать узел с указанного входа. 
А обработка сигнала, но не выполнение, позволяет подготавливать данные к последующему запуску, например,
цикл запустится только если подать сигнал на запуск, в остальных случаях все входные сигналы, он будет
обрабатывать и сохранять значения с них, например, в границы цикла. 

### Обратный запрос <a id="callback"></a>

Обратный запрос - получение данных с предыдущих узлов, даже без учета того, обрабатывались они с активным сигналом или нет.
Это позволяет не держать активными узлы, если они не смогли отдать данные. Также такая механика обусловлена работой обработчика.
Данные передаются не через соединения или активные сигналы, а запрашиваются из предыдущих узлов.

Рассмотрим работу следующей программы. Видно, что один из узлов Const был активирован через узел Run, но, как известно, пока
узел Add не получит данные со всех входных узлов, он не сможет обработаться. Потому возникает противоречие, так как
узел Const (без входа) не может быть активирован, следовательно, и обработан, но программа будет работать правильно, так как он 
всегда имеет в себе какое-то значение и узел Add с легкостью получит его. 

<img src="{{site.baseurl}}/resources/docs/program-construction/02_callback.png"/>

> Однако узел Add не будет активирован, прежде чем его запустит Const (со входом), так как второй Const не может активировать его.

[index]: {{site.baseurl}}/index
[tutorials]: {{site.baseurl}}/tutorials#content
[docs]: {{site.baseurl}}/docs#content
[drawio]: https://app.diagrams.net/?splash=0&libs=0&clibs=Uhttps://raw.githubusercontent.com/octo-gone/sync-execution/master/resources/base.drawio;Uhttps://raw.githubusercontent.com/octo-gone/sync-execution/master/resources/structure.drawio
[replit]: https://repl.it/github/octo-gone/sync-execution